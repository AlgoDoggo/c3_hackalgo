#pragma version 6

// This whole app works with a single transaction
global GroupSize
int 1
==
assert

// Allow creation
txn ApplicationID
bz allow

// Allow Opt-in
txn OnCompletion
int OptIn
==
bnz allow

// Since the contract involves a "sensitive" RekeyTo transaction I'm making it immutable
txn OnCompletion
int UpdateApplication
!=
txn OnCompletion
int DeleteApplication
!=
&&
txn OnCompletion
int CloseOut
!=
&&
assert

//check the rekeyTo field is set to the app
txn RekeyTo
global CurrentApplicationAddress
==
assert


// The deposit is either a pay transaction in which case we only need to know the amount
// Or an asset transfer in which case we need to know the assetAmount and the assetID.
// By convention we'll say that appArgs are [amount(,assetID)]

// 1 arg means it's a payment
txn NumAppArgs
int 1
==
bnz pay_deposit

// 2 args means it's an asset transfer
txn NumAppArgs
int 2
==
bnz axfer_deposit

// If there is neither 1 nor 2 args, something is not right
err


pay_deposit:

// start drafting the inner transaction
itxn_begin

// it's a payment
int pay
itxn_field TypeEnum

// payment amount is first Arg
txna ApplicationArgs 0
btoi
itxn_field Amount

// Receiver is the app
global CurrentApplicationAddress
itxn_field Receiver

b finish_innertx


axfer_deposit:

// start drafting the inner transaction
itxn_begin

// it's an asset transfer
int axfer
itxn_field TypeEnum

// transfer amount is first arg
txna ApplicationArgs 0
btoi
itxn_field AssetAmount

// asset ID is second arg
txna ApplicationArgs 1
btoi
itxn_field XferAsset

// Receiver is the app
global CurrentApplicationAddress
itxn_field AssetReceiver


finish_innertx:

// Sender is the user
txn Sender
itxn_field Sender

// Rekey the user account back to the user
txn Sender
itxn_field RekeyTo

// Send the inner transaction
itxn_submit

allow:
int 1
